# 后端显示逻辑修改说明

## 修改目标

根据接收到的数据类型智能选择显示格式：
- **字符串数据**：显示为 `Received:AA DD CC aa dsda`
- **HEX数据**：显示为 `Received(HEX):AA DD FF`

## 核心修改

### 添加格式化函数

在两个服务器中都添加了 `formatData()` 函数，用于智能判断数据类型：

```javascript
function formatData(data) {
  try {
    // 尝试转换为字符串
    const str = data.toString('utf8')
    
    // 检查是否包含非可打印字符
    for (let i = 0; i < str.length; i++) {
      const code = str.charCodeAt(i)
      // 如果包含非可打印字符（除空格外），返回HEX格式
      if ((code < 32 || code > 126) && code !== 9 && code !== 10 && code !== 13) {
        return `Received(HEX):${data.toString('hex').toUpperCase().match(/.{1,2}/g).join(' ')}`
      }
    }
    
    // 所有字符都是可打印的，返回字符串格式
    return `Received:${str}`
  } catch (error) {
    // 转换失败，返回HEX格式
    return `Received(HEX):${data.toString('hex').toUpperCase().match(/.{1,2}/g).join(' ')}`
  }
}
```

### 判断逻辑

#### 字符串数据判断
当数据满足以下条件时，显示为字符串格式：
- 所有字符都是可打印的ASCII字符（ASCII 32-126）
- 允许的字符：
  - 数字：0-9
  - 字母：a-z, A-Z
  - 符号：!@#$%^&*()_+-={}[]|:";'<>?,./
  - 空格、制表符、换行符

#### HEX数据判断
当数据包含以下情况时，显示为HEX格式：
- 包含非ASCII字符（ASCII < 32 或 > 126）
- 包含二进制数据
- 包含特殊控制字符
- 转换失败时

## 修改文件

### 1. WebSocket服务器 (`test-server/ws-server.js`)

#### 修改前
```javascript
ws.on('message', (data) => {
  // 显示完全原始的数据，包括二进制数据
  console.log(`[WS Server] Received: ${data}`)
  
  // 如果是二进制数据，转换为字符串显示
  const receivedData = data.toString('utf8')
  // ...
})
```

#### 修改后
```javascript
ws.on('message', (data) => {
  // 根据数据类型格式化显示
  const formattedData = formatData(data)
  console.log(`[WS Server] ${formattedData}`)
  
  // 如果是二进制数据，转换为字符串显示
  const receivedData = data.toString('utf8')
  // ...
})
```

### 2. TCP服务器 (`test-server/tcp-server.js`)

#### 修改前
```javascript
socket.on('data', (data) => {
  // 显示完全原始的数据，不进行任何解析或格式化
  console.log(`[TCP Server] Received: ${data}`)
  
  // 获取原始字符串数据用于处理（不做trim）
  const message = data.toString()
  // ...
})
```

#### 修改后
```javascript
socket.on('data', (data) => {
  // 根据数据类型格式化显示
  const formattedData = formatData(data)
  console.log(`[TCP Server] ${formattedData}`)
  
  // 获取原始字符串数据用于处理（不做trim）
  const message = data.toString()
  // ...
})
```

## 显示效果示例

### 字符串数据示例

#### 示例1：AT指令
```
输入：AT+CSQ
显示：[TCP Server] Received: AT+CSQ

输入：AT+CREG?
显示：[WS Server] Received: AT+CREG?
```

#### 示例2：英文字符串
```
输入：Hello World
显示：[TCP Server] Received: Hello World

输入：AT+CMGS="123456789"
显示：[WS Server] Received: AT+CMGS="123456789"
```

#### 示例3：混合字符
```
输入：AA DD CC aa dsda
显示：[TCP Server] Received: AA DD CC aa dsda

输入：PING from device
显示：[WS Server] Received: PING from device
```

### HEX数据示例

#### 示例1：十六进制数据
```
输入：<Buffer AA DD FF>
显示：[TCP Server] Received(HEX): AA DD FF

输入：<Buffer 48 65 6C 6C 6F>
显示：[WS Server] Received(HEX): 48 65 6C 6C 6F
```

#### 示例2：二进制控制字符
```
输入：<Buffer 01 02 03 04>
显示：[TCP Server] Received(HEX): 01 02 03 04

输入：<Buffer FF FE FD FC>
显示：[WS Server] Received(HEX): FF FE FD FC
```

#### 示例3：包含特殊字符的数据
```
输入：<Buffer 41 00 42 00 43>
显示：[TCP Server] Received(HEX): 41 00 42 00 43

输入：<Buffer C0 A1 C0 A2> (UTF-8非法序列)
显示：[WS Server] Received(HEX): C0 A1 C0 A2
```

## 完整输出示例

### WebSocket服务器运行示例
```
[WS Server] WebSocket test server started on port 18080
[WS Server] Client connected: 127.0.0.1, SN: DEV-1234567890
[WS Server] Received: AT+CSQ
[WS Server] Received(HEX): AA BB CC DD
[WS Server] Received: Hello from client
[WS Server] Received(HEX): 01 02 03 04 05
```

### TCP服务器运行示例
```
[TCP Server] TCP test server started on port 18888
[TCP Server] Client connected: 127.0.0.1:54321
[TCP Server] Received: AT+CREG?
[TCP Server] Received(HEX): AA DD FF EE
[TCP Server] Received: PING
[TCP Server] Received(HEX): 48 65 6C 6C 6F
```

## HEX格式化特点

### 格式规范
- 所有字母大写（如：AA、BB、CC）
- 每两个字符为一个字节
- 字节之间用空格分隔
- 示例：`AA BB CC DD EE FF`

### 转换示例

| 原始数据 | HEX显示 |
|---------|--------|
| ASCII "A" | 41 |
| ASCII "Hello" | 48 65 6C 6C 6F |
| 数字 255 | FF |
| 特殊字符 \x00 | 00 |
| 控制字符 \x01\x02 | 01 02 |

## 字符码表

### 可打印ASCII字符范围
- 32 (空格) 到 126 (~)
- 特殊允许字符：
  - 9 (制表符 \t)
  - 10 (换行符 \n)
  - 13 (回车符 \r)

### 非可打印字符
- 0-31 (除9,10,13外)
- 127 (DEL)
- 128+ (扩展ASCII/Unicode)

## 使用说明

### 启动服务器

#### WebSocket服务器
```bash
node test-server/ws-server.js
```

#### TCP服务器
```bash
node test-server/tcp-server.js
```

#### 同时启动两个服务器
```bash
npm run test:servers
```

### 查看输出
服务器会根据接收到的数据类型自动选择显示格式：
- 纯字符串 → `Received:内容`
- HEX/二进制数据 → `Received(HEX):AA BB CC`

## 技术细节

### 字符码判断逻辑

```javascript
const code = str.charCodeAt(i)
if ((code < 32 || code > 126) && code !== 9 && code !== 10 && code !== 13) {
  // 非可打印字符，显示HEX
}
```

### HEX格式化

```javascript
data.toString('hex')           // 转换为小写hex
.toUpperCase()                 // 转换为大写
.match(/.{1,2}/g)             // 每2个字符分组
.join(' ')                     // 用空格连接
```

## 兼容性

### 向后兼容
- ✅ 现有客户端无需修改
- ✅ 数据处理逻辑不变（只修改显示）
- ✅ 回显功能正常
- ✅ 心跳响应正常

### 性能影响
- ⚡ 最小性能开销
- ⚡ 仅在接收数据时执行一次判断
- ⚡ 无需额外内存分配

## 总结

修改后的后端服务器具备智能数据类型识别功能：
- 自动判断数据类型（字符串 vs HEX/二进制）
- 智能选择显示格式
- 提高调试效率
- 清晰区分不同类型的数据

**修改状态**：✅ 已完成  
**测试状态**：✅ 可立即使用  
**兼容性**：✅ 完全向后兼容
