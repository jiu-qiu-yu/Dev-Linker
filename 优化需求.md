将“4G模拟模块”做得更像真实的工业模组，核心就在于**多协议支持**、**灵活的地址配置**以及**连接后的注册/登录包机制**。

基于你提供的代码文件，我为你制定了一套优化方案。我们将分三步走：

1. **数据结构升级**：增加“登录包”配置和扩展协议类型。
2. **UI 交互优化**：合并地址栏，支持 URL 解析，增加登录包配置卡片。
3. **核心逻辑实现**：实现连接成功后自动发送登录包的逻辑。

以下是具体的修改代码建议：



### 第一步：更新类型定义



我们需要扩展协议类型，并增加登录包（Login/Registration）的配置结构。

**修改文件：** `src/shared/types.ts`

TypeScript

```
// src/shared/types.ts

// 1. 扩展协议类型
export type ConnectionProtocol = 'ws' | 'wss' | 'tcp' | 'udp' | 'mqtt' | 'http'

// ... 其他保持不变

// 2. 新增登录包配置接口
export interface LoginConfig {
  enabled: boolean
  content: string
  format: DataFormat
}

// 3. 更新 ConfigManager 导出的 AppConfig (需在 config-manager.ts 中同步更新)
// 此处仅展示 types.ts 的修改，记得同步
```

------



### 第二步：更新状态管理 (Store)



在 Store 中添加登录包的状态管理，并处理地址解析逻辑。

**修改文件：** `src/renderer/src/store/connection.ts`

TypeScript

```
// src/renderer/src/store/connection.ts
import { defineStore } from 'pinia'
import { ref } from 'vue'
import { DataFormatter } from '../utils/data-formatter'
import type { ConnectionProtocol, LoginConfig } from '@shared/types' // 假设你更新了引用

// ... 其他接口定义

export const useConnectionStore = defineStore('connection', () => {
  // ... 原有的 serverConfig, deviceConfig ...

  // 1. 新增：登录/注册包配置
  const loginConfig = ref<LoginConfig>({
    enabled: false,
    content: '',
    format: 'string'
  })

  // ... 原有代码 ...

  // 2. 新增：更新登录包配置
  const updateLoginConfig = (config: Partial<LoginConfig>) => {
    loginConfig.value = { ...loginConfig.value, ...config }
    saveConfig()
  }

  // 3. 修改：保存配置 (加入 loginConfig)
  const saveConfig = () => {
    const config = {
      server: serverConfig.value,
      device: deviceConfig.value,
      heartbeat: heartbeatConfig.value,
      dataInteraction: dataInteractionConfig.value,
      login: loginConfig.value // 保存登录配置
    }
    localStorage.setItem('devlinker-config', JSON.stringify(config))
  }

  // 4. 修改：加载配置 (加入 loginConfig)
  const loadConfig = () => {
    const saved = localStorage.getItem('devlinker-config')
    if (saved) {
      try {
        const config = JSON.parse(saved)
        // ... 其他加载逻辑
        loginConfig.value = config.login || loginConfig.value
        // ...
      } catch (error) {
        console.error('Failed to load config:', error)
      }
    }
  }
  
  // 5. 辅助函数：解析完整的 URL 地址
  // 用户输入 ws://localhost:18080 时自动拆解
  const parseConnectionString = (urlStr: string) => {
    try {
      // 简单的补全，如果用户没写协议，默认 tcp:// 或 ws://
      if (!urlStr.includes('://')) {
        urlStr = 'ws://' + urlStr
      }
      
      const url = new URL(urlStr)
      const protocolStr = url.protocol.replace(':', '')
      
      // 更新 serverConfig
      if (['ws', 'wss', 'tcp', 'udp', 'mqtt', 'http'].includes(protocolStr)) {
         serverConfig.value.protocol = protocolStr as ConnectionProtocol
      }
      
      serverConfig.value.host = url.hostname
      serverConfig.value.port = parseInt(url.port) || (protocolStr === 'http' ? 80 : 18080)
      
      // 如果 URL 里面带了 ?sn=xxx，也同步更新 deviceConfig
      const sn = url.searchParams.get('sn')
      if (sn) {
        deviceConfig.value.sn = sn
      }
      
      return true
    } catch (e) {
      console.error('URL Parse Error', e)
      return false
    }
  }

  return {
    // ... 导出原有属性
    loginConfig, // 导出新状态
    updateLoginConfig,
    parseConnectionString, // 导出解析函数
    // ...
  }
})
```

------



### 第三步：优化连接配置 UI



这里是重头戏。我们将地址栏合并，并添加登录包配置卡片。

**修改文件：** `src/renderer/src/components/ConnectionConfig.vue`

HTML

```
<template>
  <div class="config-panel">
    <div class="panel-header">
      <h3>连接配置</h3>
    </div>

    <div class="config-scroll-area">
      <el-scrollbar>
        <div class="form-content">
          <el-form :model="form" label-position="top" size="default">
            
            <el-card shadow="never" class="config-card">
              <el-form-item label="服务器地址 (完整格式)">
                <el-input 
                  v-model="fullAddress" 
                  placeholder="例: ws://localhost:18080" 
                  @blur="handleAddressBlur"
                  clearable
                >
                  <template #prepend>
                    <el-select v-model="form.protocol" style="width: 85px" @change="updateFullAddress">
                      <el-option label="WS" value="ws" />
                      <el-option label="WSS" value="wss" />
                      <el-option label="TCP" value="tcp" />
                      <el-option label="UDP" value="udp" disabled />
                      <el-option label="MQTT" value="mqtt" disabled />
                    </el-select>
                  </template>
                </el-input>
                <div class="url-preview" v-if="previewUrl">
                  <small>预览: {{ previewUrl }}</small>
                </div>
              </el-form-item>

              <div class="host-port-row">
                <el-form-item label="主机" style="flex: 2; margin-right: 10px; margin-bottom: 0;">
                  <el-input v-model="form.host" @input="updateFullAddress" />
                </el-form-item>
                <el-form-item label="端口" style="flex: 1; margin-bottom: 0;">
                  <el-input-number v-model="form.port" :min="1" :max="65535" style="width: 100%" :controls="false" @change="updateFullAddress" />
                </el-form-item>
              </div>

              <el-form-item label="设备序列号 (SN)" style="margin-top: 16px;">
                <el-input v-model="form.sn" placeholder="唯一标识">
                  <template #append>
                    <el-button @click="generateSN"><el-icon><Refresh /></el-icon></el-button>
                  </template>
                </el-input>
              </el-form-item>
            </el-card>

            <el-card shadow="never" class="config-card">
              <template #header>
                <div class="card-header-row">
                  <span>登录/注册包 (连接后发送一次)</span>
                  <el-switch v-model="form.login.enabled" size="small" :disabled="isConnectionActive" @change="onLoginToggle" />
                </div>
              </template>

              <div v-if="form.login.enabled && !isConnectionActive" class="login-options">
                 <el-form-item label="数据格式">
                  <el-radio-group v-model="form.login.format" size="small" @change="handleLoginFormatChange">
                    <el-radio-button label="string">字符串</el-radio-button>
                    <el-radio-button label="hex">十六进制</el-radio-button>
                  </el-radio-group>
                </el-form-item>
                
                <el-form-item label="发送内容">
                  <el-input
                    v-model="loginDisplayContent"
                    type="textarea"
                    :rows="2"
                    resize="none"
                    placeholder="连接成功后立即发送此数据，常用于设备鉴权"
                    @input="handleLoginInput"
                  />
                </el-form-item>
              </div>
               <div v-else-if="form.login.enabled" class="login-status">
                  <el-tag size="small" type="info">{{ form.login.format === 'hex' ? 'HEX' : 'STR' }}</el-tag>
                  <span class="content-preview">{{ loginDisplayContent }}</span>
               </div>
            </el-card>

            <el-card shadow="never" class="config-card">
               </el-card>

          </el-form>
        </div>
      </el-scrollbar>
    </div>
    </div>
</template>

<script setup lang="ts">
// ... 引入保持不变
import { DataFormatter } from '@/utils/data-formatter'

// ... 其他 store 引用

const form = ref({
  // ... 原有字段
  // 新增 login 字段
  login: {
    enabled: false,
    content: '',
    format: 'string' as 'string' | 'hex'
  }
})

// 地址栏相关逻辑
const fullAddress = ref('ws://localhost:18080')

// 预览最终连接地址（带SN）
const previewUrl = computed(() => {
  const base = `${form.value.protocol}://${form.value.host}:${form.value.port}`
  // 只有 WS/HTTP 协议 URL 带参数，TCP/UDP 通常不这么写，但为了显示统一可以展示
  return `${base}?sn=${form.value.sn}`
})

const isConnectionActive = computed(() => {
  return connectionStatus.value === 'connected' || connectionStatus.value === 'connecting'
})

// 登录包相关变量
const rawLoginContent = ref('')
const loginDisplayContent = ref('')
const lastLoginFormat = ref<'string' | 'hex'>('string')

// 地址输入框失焦处理
const handleAddressBlur = () => {
  connectionStore.parseConnectionString(fullAddress.value)
  // 从 store 同步回 form
  form.value.host = connectionStore.serverConfig.host
  form.value.port = connectionStore.serverConfig.port
  form.value.protocol = connectionStore.serverConfig.protocol
  // 如果 URL 里没 sn，保持原有的 sn 不变
}

// 手动修改协议/主机/端口时，反向更新 fullAddress
const updateFullAddress = () => {
  fullAddress.value = `${form.value.protocol}://${form.value.host}:${form.value.port}`
}

// 登录包 Toggle
const onLoginToggle = (enabled: boolean) => {
  // 保存配置逻辑...
  connectionStore.updateLoginConfig({ enabled })
}

// 登录包输入处理 (参考心跳包的逻辑，复用 DataFormatter)
const handleLoginInput = (value: string) => {
  if (form.value.login.format === 'hex') {
    const cleaned = DataFormatter.sanitizeHexInput(value)
    rawLoginContent.value = cleaned
    loginDisplayContent.value = DataFormatter.formatHexWithSpaces(cleaned)
    form.value.login.content = cleaned
  } else {
    loginDisplayContent.value = value
    form.value.login.content = value
  }
  connectionStore.updateLoginConfig({ 
    content: form.value.login.content,
    format: form.value.login.format
  })
}

// 登录包格式转换
const handleLoginFormatChange = (newFormat: 'string' | 'hex') => {
  // ... 逻辑同心跳包格式转换，使用 DataFormatter ...
  // 此处省略具体转换代码，直接复制 handleFormatChange 的逻辑修改变量名即可
}

// onMounted 中增加加载 Login 配置
onMounted(() => {
  connectionStore.loadConfig()
  // ... 其他加载
  const savedLogin = connectionStore.loginConfig
  form.value.login.enabled = savedLogin.enabled ?? false
  form.value.login.format = savedLogin.format || 'string'
  form.value.login.content = savedLogin.content || ''
  
  // 初始化登录包显示
  if (form.value.login.format === 'hex' && form.value.login.content) {
    rawLoginContent.value = form.value.login.content
    loginDisplayContent.value = DataFormatter.formatHexWithSpaces(rawLoginContent.value)
  } else {
    loginDisplayContent.value = form.value.login.content
    rawLoginContent.value = ''
  }

  // 初始化地址栏
  updateFullAddress()
})
</script>

<style scoped>
/* 增加样式 */
.host-port-row {
  display: flex;
  gap: 10px;
  margin-top: 10px;
  padding: 0 5px;
}
.url-preview {
  font-size: 12px;
  color: #909399;
  margin-top: 4px;
  word-break: break-all;
}
.content-preview {
  font-family: 'Consolas', monospace;
  color: #606266;
  margin-left: 8px;
  word-break: break-all;
}
</style>
```

------



### 第四步：核心逻辑 - 连接后自动发送登录包



我们需要修改 `websocket.ts` 和 `tcp.ts`，在连接建立成功的回调中，检查并发送登录包。

**修改文件 1：** `src/renderer/src/utils/websocket.ts`

TypeScript

```
// 在 connect 方法内部，ws.onopen 回调中修改

this.ws.onopen = () => {
  console.log('WebSocket connected')
  this.reconnectAttempts = 0
  this.manualDisconnect = false
  
  // --- 新增逻辑：发送登录包 ---
  const store = useConnectionStore() // 需要在文件顶部引入 store
  if (store.loginConfig.enabled && store.loginConfig.content) {
    console.log('[WebSocket] Sending Login Packet...')
    let dataToSend: string | Uint8Array = store.loginConfig.content
    
    if (store.loginConfig.format === 'hex') {
      dataToSend = DataFormatter.hexToUint8Array(store.loginConfig.content)
    }
    
    // 复用 send 方法
    this.send(dataToSend) 
    
    // 可以在 UI 上显示一条系统日志告诉用户已发送登录包
    // 这里可以通过回调或者全局事件总线通知 DataInteraction 组件
  }
  // -------------------------

  this.onOpen?.()
  resolve()
}
```

**修改文件 2：** `src/renderer/src/utils/tcp.ts`

TCP 的逻辑类似，但是因为 `tcp.ts` 是封装类，我们可以在 `onOpen` 回调触发前执行发送。

TypeScript

```
// 在 constructor 的 onTCPConnected 事件中

window.electronAPI.onTCPConnected(() => {
  console.log('[TCP] Connected event received')
  
  // --- 新增逻辑：发送登录包 ---
  const store = useConnectionStore()
  if (store.loginConfig.enabled && store.loginConfig.content) {
    console.log('[TCP] Sending Login Packet...')
    let dataToSend: string | Uint8Array = store.loginConfig.content
    
    if (store.loginConfig.format === 'hex') {
      dataToSend = DataFormatter.hexToUint8Array(store.loginConfig.content)
    }
    
    // 调用自身的 send 方法
    this.send(dataToSend)
  }
  // -------------------------

  this.onOpen?.()
})
```

------



### 总结与建议



1. **UDP 支持建议**：
   - UDP 与 TCP 类似，必须在 Electron **主进程** (`src/main`) 实现。
   - 你需要创建一个 `UdpSocketManager` 类（参考 `TCPSocketManager`），使用 Node.js 的 `dgram` 模块。
   - 前端逻辑与 TCP 几乎一致，只需在 `ConnectionConfig` 的协议下拉框中启用 UDP 选项，并调用对应的 IPC 接口。
2. **MQTT 支持建议**：
   - MQTT 比较特殊，建议引入 `mqtt` npm 包。
   - 如果连接 `ws://` 或 `wss://` 的 MQTT Broker，可以直接在渲染进程（前端）做。
   - 如果连接 `tcp://` 的 MQTT Broker，必须在主进程做。
   - 鉴于这是模拟 4G 模块，通常是 TCP MQTT，建议在主进程集成 `mqtt` 库。
3. **登录包逻辑**：
   - 上面的代码实现了“连接成功后立即发送”。这对于 TCP/WebSocket 非常有效，模拟了设备上电联网后第一时间向服务器报到的行为（Registration）。
   - 确保 `DataFormatter` 工具类已正确引入到 `websocket.ts` 和 `tcp.ts` 中。

这一套修改方案不仅满足了你对 **URL 格式** 的要求（通过 UI 自动解析和拼接），还完美增加了 **登录注册包** 功能，极大地增强了模拟器的真实性。