你的问题非常典型。很多初学者在使用 Electron + Vue 开发桌面应用时，容易沿用 Web 网页的“流式布局”思维（内容越多页面越长），而桌面应用（尤其是工具类软件）需要的是**“视口布局”思维**（内容适应窗口大小，内部区域独立滚动）。

目前的严重排版问题（按键不显示、需要放大窗口）是因为**没有限制父容器的高度**以及**缺乏弹性的 Flex 布局结构**。

我将按照 **类似 Postman 或 VS Code 的专业开发者工具风格** 重构你的前端布局。



### 重构目标



1. **全屏适应**：应用永远填满窗口，不出现外层滚动条。
2. **分区独立滚动**：配置栏内容过多时只滚动配置栏，日志过多时只滚动日志区。
3. **固定底部操作栏**：连接/断开按钮固定在侧边栏底部，永远可见。
4. **自适应日志区**：日志区域自动占据剩余空间，而不是固定高度。

------



### 第一步：全局样式重置 (App.vue)



我们需要确保应用的最外层容器严格占据屏幕高度，并禁止全局滚动。

**文件：** `src/renderer/src/App.vue`

代码段

```
<template>
  <div id="app">
    <router-view />
  </div>
</template>

<script setup lang="ts">
</script>

<style>
/* 全局样式重置 */
html, body {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  overflow: hidden; /* 禁止 body 滚动 */
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  -webkit-font-smoothing: antialiased;
}

#app {
  width: 100%;
  height: 100%;
  background-color: #f5f7fa; /* 更柔和的背景色 */
}

/* 滚动条美化 (Webkit) */
::-webkit-scrollbar {
  width: 6px;
  height: 6px;
}
::-webkit-scrollbar-thumb {
  background: #c0c4cc;
  border-radius: 3px;
}
::-webkit-scrollbar-track {
  background: transparent;
}
</style>
```

------



### 第二步：主布局重构 (MainView.vue)



采用经典的 **Header + Sidebar + Main** 布局。关键是使用 CSS Flexbox 确保高度撑满。

**文件：** `src/renderer/src/views/MainView.vue`

代码段

```
<template>
  <div class="layout-container">
    <header class="app-header">
      <div class="brand">
        <el-icon :size="20"><Connection /></el-icon>
        <span class="app-name">Dev-Linker</span>
        <el-tag size="small" effect="plain" class="version-tag">v1.2.2</el-tag>
      </div>
      <div class="window-actions">
        <el-button link @click="showAbout = true">
          <el-icon><InfoFilled /></el-icon>
        </el-button>
      </div>
    </header>

    <div class="app-body">
      <aside class="sidebar">
        <ConnectionConfig />
      </aside>

      <main class="content-area">
        <DataInteraction />
      </main>
    </div>

    <el-dialog v-model="showAbout" title="关于 Dev-Linker" width="400px">
      <div class="about-content">
        <p><strong>Dev-Linker</strong></p>
        <p>虚拟4G模块模拟器 - 物联网开发调试工具</p>
      </div>
    </el-dialog>
  </div>
</template>

<script setup lang="ts">
import { ref } from 'vue'
import { Connection, InfoFilled } from '@element-plus/icons-vue'
import ConnectionConfig from '@/components/ConnectionConfig.vue'
import DataInteraction from '@/components/DataInteraction.vue'

const showAbout = ref(false)
</script>

<style scoped>
.layout-container {
  display: flex;
  flex-direction: column;
  height: 100vh; /* 占满视口高度 */
  background-color: #fff;
}

.app-header {
  height: 48px; /* 缩小头部高度，节省空间 */
  background-color: #2b303b; /* 深色专业风格 */
  color: #fff;
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0 16px;
  flex-shrink: 0; /* 防止头部被压缩 */
  -webkit-app-region: drag; /* 允许拖拽窗口 */
}

.brand {
  display: flex;
  align-items: center;
  gap: 10px;
  font-weight: 600;
}

.version-tag {
  background: rgba(255,255,255,0.1);
  border: none;
  color: #aaa;
}

.window-actions {
  -webkit-app-region: no-drag;
}

.app-body {
  flex: 1; /* 占据剩余高度 */
  display: flex;
  overflow: hidden; /* 防止内部溢出导致整体滚动 */
}

.sidebar {
  width: 320px; /* 固定宽度 */
  background-color: #f8f9fa;
  border-right: 1px solid #e4e7ed;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.content-area {
  flex: 1; /* 占据剩余宽度 */
  background-color: #fff;
  overflow: hidden; /* 内部组件自己处理滚动 */
  display: flex;
  flex-direction: column;
}
</style>
```

------



### 第三步：侧边栏重构 (ConnectionConfig.vue)



这是最关键的一步。我们将侧边栏分为两个部分：

1. **上部滚动区**：放所有配置项，内容多时可滚动。
2. **底部固定区**：放“连接/断开”按钮，**永远固定在底部**，不会被遮挡。

**文件：** `src/renderer/src/components/ConnectionConfig.vue`

代码段

```
<template>
  <div class="config-panel">
    <div class="panel-header">
      <h3>连接配置</h3>
    </div>

    <div class="config-scroll-area">
      <el-scrollbar>
        <div class="form-content">
          <el-form :model="form" label-position="top" size="default">
            <el-card shadow="never" class="config-card">
              <el-form-item label="协议 & 地址">
                <el-input v-model="form.host" placeholder="IP/域名">
                  <template #prepend>
                    <el-select v-model="form.protocol" style="width: 90px" @change="onProtocolChange">
                      <el-option label="WS" value="ws" />
                      <el-option label="WSS" value="wss" />
                      <el-option label="TCP" value="tcp" />
                    </el-select>
                  </template>
                </el-input>
              </el-form-item>

              <el-form-item label="端口">
                <el-input-number v-model="form.port" :min="1" :max="65535" style="width: 100%" controls-position="right" />
              </el-form-item>

              <el-form-item label="设备 SN">
                <el-input v-model="form.sn" placeholder="唯一标识">
                  <template #append>
                    <el-button @click="generateSN"><el-icon><Refresh /></el-icon></el-button>
                  </template>
                </el-input>
              </el-form-item>
            </el-card>

            <el-card shadow="never" class="config-card">
              <template #header>
                <div class="card-header-row">
                  <span>心跳包</span>
                  <el-switch v-model="form.heartbeat.enabled" size="small" :disabled="isHeartbeatDisabled" @change="onHeartbeatToggle" />
                </div>
              </template>

              <div v-if="form.heartbeat.enabled" class="heartbeat-options">
                <el-form-item label="间隔 (秒)">
                  <el-input-number v-model="form.heartbeat.interval" :min="1" size="small" style="width: 100%" />
                </el-form-item>

                <el-form-item label="格式">
                  <el-radio-group v-model="form.heartbeat.format" size="small" @change="handleFormatChange">
                    <el-radio-button label="string">STR</el-radio-button>
                    <el-radio-button label="hex">HEX</el-radio-button>
                  </el-radio-group>
                </el-form-item>

                <el-form-item label="内容">
                  <el-input 
                    v-model="heartbeatDisplayContent" 
                    type="textarea" 
                    :rows="2" 
                    resize="none"
                    @input="handleHeartbeatInput" 
                  />
                </el-form-item>
              </div>
            </el-card>
          </el-form>
        </div>
      </el-scrollbar>
    </div>

    <div class="panel-footer">
      <el-button
        v-if="connectionStatus !== 'connected'"
        type="primary"
        size="large"
        class="action-btn"
        :loading="isConnecting"
        :disabled="!canConnect"
        @click="handleConnect"
      >
        {{ isConnecting ? '连接中...' : '连接服务器' }}
      </el-button>

      <el-button
        v-else
        type="danger"
        size="large"
        class="action-btn"
        @click="handleDisconnect"
      >
        断开连接
      </el-button>
      
      <div class="status-bar" :class="connectionStatus">
        <div class="status-dot"></div>
        <span>{{ statusText }}</span>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
// ... 粘贴你原本的 script 代码 ...
import { ref, computed, onMounted, watch } from 'vue'
import { useConnectionStore } from '@/store/connection'
import { WebSocketManager } from '@/utils/websocket'
import { TCPSocket } from '@/utils/tcp'
import { DataFormatter } from '@/utils/data-formatter'
import { Refresh } from '@element-plus/icons-vue' // 确保只引入用到的图标
import { ElMessage } from 'element-plus'

// ... 这里完全复用你原来的逻辑代码 ...
// ... 注意：statusText 和 statusType 的计算属性逻辑在 template 中用到了 ...
// ... 补充一下 icons 的引入 ...

const connectionStore = useConnectionStore()
const wsManager = new WebSocketManager()
const tcpSocket = new TCPSocket()

// ... (复制你原来组件中的所有变量和函数定义) ...
// 比如 form, isConnecting, connectionStatus 等等
// ...
// 只是要注意 template 中的变量名是否和 script 一致
const form = ref({
  host: 'localhost',
  port: 18080,
  protocol: 'ws' as 'ws' | 'wss' | 'tcp',
  sn: 'DEV-' + Date.now(),
  heartbeat: {
    enabled: false,
    interval: 30,
    content: '',
    format: 'string' as 'string' | 'hex'
  }
})
const isConnecting = ref(false)
const lastHeartbeatFormat = ref<'string' | 'hex'>('string')
const rawHeartbeatContent = ref('')
const heartbeatDisplayContent = ref('')
const connectionStatus = computed(() => connectionStore.connectionStatus)

// ... 你的其他函数 (onProtocolChange, handleConnect 等) ...

// 为了配合新UI，我们需要 statusText
const statusText = computed(() => {
  const map: any = { disconnected: '未连接', connecting: '连接中...', connected: '已连接', failed: '连接失败' }
  return map[connectionStatus.value] || '未知状态'
})
const isHeartbeatDisabled = computed(() => connectionStatus.value === 'connected' || connectionStatus.value === 'connecting')
const canConnect = computed(() => form.value.host && form.value.port && form.value.sn)

// ... 下面是你原有的所有方法，直接复制即可 ...
// generateSN, onProtocolChange, onHeartbeatToggle, handleIntervalChange, handleHeartbeatInput, handleFormatChange, handleConnect, handleDisconnect, onMounted, watch...
const onProtocolChange = (protocol: 'ws' | 'wss' | 'tcp') => {
  const defaultPorts = { ws: 18080, wss: 18443, tcp: 18888 }
  form.value.port = defaultPorts[protocol]
  connectionStore.updateServerConfig({ protocol, port: form.value.port })
}
const generateSN = () => {
  form.value.sn = 'DEV-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9).toUpperCase()
  ElMessage.success('SN 生成成功')
}
const onHeartbeatToggle = (enabled: boolean) => {
  if (enabled && !form.value.heartbeat.content) {
    form.value.heartbeat.content = 'PING'
    heartbeatDisplayContent.value = 'PING'
  }
  connectionStore.updateHeartbeatConfig({ enabled, content: form.value.heartbeat.content, interval: form.value.heartbeat.interval, format: form.value.heartbeat.format })
}
// ... 这里的代码太长了，请将你原文件中的逻辑部分复制过来，逻辑本身是没问题的 ...
const handleFormatChange = (newFormat: 'string' | 'hex') => {
    // ... 复用原有逻辑 ...
      try {
    const oldFormat = form.value.heartbeat.format

    if (newFormat === 'hex') {
      const currentData = heartbeatDisplayContent.value || form.value.heartbeat.content || ''
      if (currentData.trim() || currentData.length > 0) {
        const converted = DataFormatter.stringToHex(currentData)
        rawHeartbeatContent.value = DataFormatter.sanitizeHexInput(converted)
        heartbeatDisplayContent.value = DataFormatter.formatHexWithSpaces(rawHeartbeatContent.value)
        form.value.heartbeat.content = DataFormatter.sanitizeHexInput(converted)
      } else {
        rawHeartbeatContent.value = ''
        heartbeatDisplayContent.value = ''
        form.value.heartbeat.content = ''
      }
    } else {
      const hexData = rawHeartbeatContent.value || form.value.heartbeat.content || ''
      if (hexData) {
        const converted = DataFormatter.hexToString(hexData)
        heartbeatDisplayContent.value = converted
        rawHeartbeatContent.value = ''
        form.value.heartbeat.content = converted
      } else {
        heartbeatDisplayContent.value = ''
        rawHeartbeatContent.value = ''
        form.value.heartbeat.content = ''
      }
    }
    form.value.heartbeat.format = newFormat
    lastHeartbeatFormat.value = newFormat
    connectionStore.updateHeartbeatConfig({
      format: newFormat,
      content: form.value.heartbeat.content
    })
  } catch (error) {
    ElMessage.error('格式转换失败：' + (error as Error).message)
  }
}
const handleHeartbeatInput = (value: string) => {
    // ... 复用原有逻辑 ...
      if (form.value.heartbeat.format === 'hex') {
    const cleaned = DataFormatter.sanitizeHexInput(value)
    rawHeartbeatContent.value = cleaned
    const formatted = DataFormatter.formatHexWithSpaces(cleaned)
    heartbeatDisplayContent.value = formatted
    form.value.heartbeat.content = cleaned
    connectionStore.updateHeartbeatConfig({ content: cleaned, format: 'hex' })
  } else {
    heartbeatDisplayContent.value = value
    form.value.heartbeat.content = value
    connectionStore.updateHeartbeatConfig({ content: value, format: 'string' })
  }
}
const handleConnect = async () => {
    // ... 复用原有逻辑 ...
    if (!canConnect.value) { return }
    isConnecting.value = true
    connectionStore.setConnectionStatus('connecting')
    try {
        connectionStore.updateServerConfig({ host: form.value.host, port: form.value.port, protocol: form.value.protocol })
        connectionStore.updateDeviceConfig({ sn: form.value.sn })
        connectionStore.updateHeartbeatConfig({ enabled: form.value.heartbeat.enabled, interval: form.value.heartbeat.interval, content: form.value.heartbeat.content, format: form.value.heartbeat.format })
        
        if (form.value.protocol === 'ws' || form.value.protocol === 'wss') {
            const url = `${form.value.protocol}://${form.value.host}:${form.value.port}`
            wsManager.onOpen = () => { connectionStore.setConnectionStatus('connected'); connectionStore.setConnectionManager('ws', wsManager); ElMessage.success('WebSocket 连接成功') }
            wsManager.onClose = () => { connectionStore.setConnectionStatus('disconnected'); connectionStore.setConnectionManager('ws', null) }
            wsManager.onError = (error) => { connectionStore.setConnectionStatus('failed'); ElMessage.error('WebSocket 连接失败') }
            wsManager.onMessage = (data) => { 
                // 这里需要触发 DataInteraction 的显示，可以通过 EventBus 或者 Store 实现，或者保持原有的 querySelector 写法（虽然不推荐但能用）
                const dataInteraction = document.querySelector('.data-interaction')
                if (dataInteraction && (dataInteraction as any).__vue__) {
                  (dataInteraction as any).__vue__.exposed.simulateReceiveData(data)
                }
            }
            await wsManager.connect(url, form.value.sn)
        } else if (form.value.protocol === 'tcp') {
             tcpSocket.onOpen = () => { connectionStore.setConnectionStatus('connected'); connectionStore.setConnectionManager('tcp', tcpSocket); ElMessage.success('TCP 连接成功') }
             tcpSocket.onClose = () => { connectionStore.setConnectionStatus('disconnected'); connectionStore.setConnectionManager('tcp', null) }
             tcpSocket.onError = (error) => { connectionStore.setConnectionStatus('failed'); ElMessage.error('TCP 连接失败') }
             tcpSocket.onData = (data) => {
                // TCP 数据接收处理
             }
             await tcpSocket.connect(form.value.host, form.value.port)
        }
    } catch (e) {
        connectionStore.setConnectionStatus('failed')
        ElMessage.error('连接失败')
    } finally {
        isConnecting.value = false
    }
}
const handleDisconnect = () => {
    if (form.value.protocol.includes('ws')) { wsManager.disconnect() } else { tcpSocket.disconnect() }
    connectionStore.setConnectionStatus('disconnected')
}

onMounted(() => {
    connectionStore.loadConfig()
    // ... 同步数据的逻辑 ...
      form.value.host = connectionStore.serverConfig.host || 'localhost'
  form.value.port = connectionStore.serverConfig.port || 18080
  form.value.protocol = connectionStore.serverConfig.protocol || 'ws'
  form.value.sn = connectionStore.deviceConfig.sn || ('DEV-' + Date.now())
  const savedHeartbeat = connectionStore.heartbeatConfig
  form.value.heartbeat.enabled = savedHeartbeat.enabled ?? false
  form.value.heartbeat.interval = savedHeartbeat.interval ?? 30
  form.value.heartbeat.format = savedHeartbeat.format || 'string'
  form.value.heartbeat.content = savedHeartbeat.content || ''
  if (form.value.heartbeat.format === 'hex' && form.value.heartbeat.content) {
    rawHeartbeatContent.value = form.value.heartbeat.content
    heartbeatDisplayContent.value = DataFormatter.formatHexWithSpaces(rawHeartbeatContent.value)
  } else {
    heartbeatDisplayContent.value = form.value.heartbeat.content || ''
    rawHeartbeatContent.value = ''
  }
})
</script>

<style scoped>
.config-panel {
  display: flex;
  flex-direction: column;
  height: 100%;
  background: #f9f9f9;
}

.panel-header {
  padding: 16px;
  border-bottom: 1px solid #e4e7ed;
  background: #fff;
}

.panel-header h3 {
  margin: 0;
  font-size: 16px;
  color: #303133;
}

.config-scroll-area {
  flex: 1;
  overflow: hidden; /* 内部 scrollbar 滚动 */
}

.form-content {
  padding: 16px;
}

.config-card {
  margin-bottom: 16px;
  border: 1px solid #ebeef5;
}

/* 压缩 Form Item 间距，让界面更紧凑 */
:deep(.el-form-item) {
  margin-bottom: 16px;
}
:deep(.el-card__header) {
  padding: 10px 15px;
  background: #fafafa;
}
:deep(.el-card__body) {
  padding: 15px;
}

.card-header-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 14px;
  font-weight: 500;
}

.panel-footer {
  padding: 16px;
  background: #fff;
  border-top: 1px solid #e4e7ed;
  box-shadow: 0 -2px 10px rgba(0,0,0,0.05);
  z-index: 10;
}

.action-btn {
  width: 100%;
  font-weight: 600;
}

.status-bar {
  margin-top: 10px;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  font-size: 12px;
  color: #909399;
}

.status-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: #909399;
}

.status-bar.connected .status-dot { background: #67c23a; }
.status-bar.connected { color: #67c23a; }
.status-bar.connecting .status-dot { background: #e6a23c; }
.status-bar.failed .status-dot { background: #f56c6c; }
</style>
```

------



### 第四步：数据交互区重构 (DataInteraction.vue)



这个区域必须使用 Flex 布局，让**日志区域自动撑满剩余高度**。

**文件：** `src/renderer/src/components/DataInteraction.vue`

代码段

```
<template>
  <div class="interaction-container">
    <div class="send-pane">
      <div class="pane-header">
        <span class="title">发送数据</span>
        <el-radio-group v-model="sendFormat" size="small">
          <el-radio-button label="string">String</el-radio-button>
          <el-radio-button label="hex">HEX</el-radio-button>
        </el-radio-group>
      </div>
      
      <div class="input-area">
        <el-input
          v-model="sendDataDisplay"
          type="textarea"
          :rows="3"
          :placeholder="sendPlaceholder"
          resize="none"
          class="custom-textarea"
          spellcheck="false"
        />
        <div class="send-tools">
          <el-button size="small" text @click="clearSendData">清空</el-button>
          <el-button 
            type="primary" 
            :disabled="!canSend || !hasSendData" 
            :loading="isSending"
            @click="handleSend"
          >
            发送
          </el-button>
        </div>
      </div>
    </div>

    <div class="log-pane">
      <div class="pane-header">
        <span class="title">运行日志</span>
        <div class="controls">
          <el-radio-group v-model="logFormat" size="small">
            <el-radio-button label="string">Str</el-radio-button>
            <el-radio-button label="hex">Hex</el-radio-button>
          </el-radio-group>
          <el-button size="small" circle @click="clearLogs">
            <el-icon><Delete /></el-icon>
          </el-button>
        </div>
      </div>

      <div class="log-scroll-container" ref="logContainer">
        <div v-if="logs.length === 0" class="empty-state">
          暂无日志数据
        </div>
        <div
          v-for="log in logs"
          :key="log.id"
          class="log-row"
          :class="log.type"
        >
          <span class="time">[{{ log.timestamp }}]</span>
          <span class="tag" :class="log.type">{{ getLogTypeLabel(log.type) }}</span>
          <span class="content">{{ log.content }}</span>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
// 这里完全保留你原来的 Script 逻辑，不需要改变任何业务逻辑
import { ref, computed, nextTick, watch, onMounted } from 'vue'
import { useConnectionStore, LogEntry } from '@/store/connection'
import { Delete } from '@element-plus/icons-vue'
import { ElMessage } from 'element-plus'
import { DataFormatter } from '@/utils/data-formatter'

const connectionStore = useConnectionStore()
const sendData = ref('')
const sendFormat = ref<'string' | 'hex'>('string')
const isSending = ref(false)
const rawSendData = ref('')
const lastSendFormat = ref('string')
const logContainer = ref<HTMLElement>()
const logs = ref<LogEntry[]>([])

// ... 复制所有原有逻辑 ...
// sendDataDisplay, canSend, hasSendData, sendPlaceholder, logFormat 等 computed
// watch(sendFormat...), watch(logFormat...), clearLogs, addLog, handleSend, simulateReceiveData...

const sendDataDisplay = computed({
  get: () => sendFormat.value === 'hex' ? DataFormatter.formatHexWithSpaces(rawSendData.value) : sendData.value,
  set: (val) => { if(sendFormat.value === 'hex') rawSendData.value = DataFormatter.sanitizeHexInput(val); else sendData.value = val; }
})
const canSend = computed(() => connectionStore.connectionStatus === 'connected')
const hasSendData = computed(() => sendFormat.value === 'hex' ? rawSendData.value.length > 0 : sendData.value.trim().length > 0)
const sendPlaceholder = computed(() => sendFormat.value === 'string' ? '请输入内容...' : '请输入HEX (如: AA BB CC)')
const logFormat = computed({
  get: () => connectionStore.dataInteractionConfig.logFormat,
  set: (value) => connectionStore.updateDataInteractionConfig({ logFormat: value })
})

const getLogTypeLabel = (type: string) => {
  const map: any = { connection: '系统', send: '发送', receive: '接收', error: '错误' }
  return map[type] || 'INFO'
}
// ... 省略中间完全一样的函数 ...
const clearSendData = () => { sendData.value = ''; rawSendData.value = '' }
const clearLogs = () => { logs.value = [] }
const handleSend = async () => {
    // 复用原逻辑
    if (!hasSendData.value) return;
    isSending.value = true
    try {
        if (connectionStore.connectionStatus !== 'connected') throw new Error('未连接')
        let dataToSend: string | Uint8Array
        if (sendFormat.value === 'hex') dataToSend = DataFormatter.hexToUint8Array(rawSendData.value)
        else dataToSend = sendData.value
        const success = await connectionStore.sendData(dataToSend)
        if (success) {
             let logContent = sendFormat.value === 'hex' ? DataFormatter.formatHexWithSpaces(rawSendData.value) : sendData.value
             addLog('send', logContent, sendFormat.value)
             sendData.value = ''; rawSendData.value = ''
        } else { throw new Error('发送失败') }
    } catch(e) { addLog('error', (e as Error).message) }
    finally { isSending.value = false }
}
const simulateReceiveData = (data: string, format: 'string'|'hex' = 'string') => addLog('receive', data, format)
const addLog = (type: any, content: string, originalFormat: any = 'string') => {
    let display = content
    if (logFormat.value !== originalFormat) { try { display = DataFormatter.convert(content, originalFormat, logFormat.value) } catch(e){} }
    logs.value.push({ id: Date.now().toString(), timestamp: new Date().toLocaleTimeString(), type, content: display, format: logFormat.value })
    nextTick(() => { if(logContainer.value) logContainer.value.scrollTop = logContainer.value.scrollHeight })
}
defineExpose({ simulateReceiveData })
onMounted(() => { connectionStore.loadConfig() })

watch(sendFormat, (n, o) => {
    // 复用原有的转换逻辑
    if (n === o) return
    try {
        if (n === 'hex') {
            rawSendData.value = DataFormatter.sanitizeHexInput(DataFormatter.stringToHex(sendData.value))
            sendData.value = ''
        } else {
            sendData.value = DataFormatter.hexToString(rawSendData.value)
            rawSendData.value = ''
        }
    } catch(e) { sendData.value=''; rawSendData.value='' }
})
watch(logFormat, (n, o) => {
    // 复用原有的日志转换逻辑
    if (n!==o && logs.value.length) {
        logs.value = logs.value.map(log => {
            try { return { ...log, content: DataFormatter.convert(log.content, o, n), format: n } } 
            catch { return log }
        })
    }
})
</script>

<style scoped>
.interaction-container {
  display: flex;
  flex-direction: column;
  height: 100%;
  padding: 0; /* 移除 padding，由内部控制 */
}

.send-pane {
  flex-shrink: 0; /* 不允许压缩 */
  border-bottom: 1px solid #e4e7ed;
  background: #fff;
  padding: 12px 16px;
}

.pane-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
}

.title {
  font-size: 14px;
  font-weight: 600;
  color: #606266;
}

.input-area {
  border: 1px solid #dcdfe6;
  border-radius: 4px;
  padding: 4px;
  transition: border-color 0.2s;
}

.input-area:focus-within {
  border-color: #409eff;
}

/* 去掉 Element 输入框的边框，使用外层边框 */
:deep(.custom-textarea .el-textarea__inner) {
  border: none;
  box-shadow: none;
  padding: 8px;
  font-family: 'Consolas', monospace;
}

.send-tools {
  display: flex;
  justify-content: flex-end;
  padding: 4px 8px 0;
  border-top: 1px dashed #ebeef5;
}

.log-pane {
  flex: 1; /* 自动占据剩余高度 */
  display: flex;
  flex-direction: column;
  background: #1e1e1e; /* 黑色背景 */
  min-height: 0; /* 关键：允许 flex 子元素小于内容高度，从而出现滚动条 */
}

.log-pane .pane-header {
  background: #252526;
  color: #ccc;
  padding: 8px 16px;
  margin-bottom: 0;
  border-bottom: 1px solid #333;
}

.log-pane .title {
  color: #ccc;
}

.log-scroll-container {
  flex: 1;
  overflow-y: auto;
  padding: 10px;
  font-family: 'Consolas', 'Monaco', monospace;
  font-size: 13px;
  line-height: 1.6;
  color: #d4d4d4;
}

.log-row {
  margin-bottom: 4px;
  word-break: break-all;
  display: flex;
  gap: 8px;
}

.log-row .time {
  color: #6a9955;
  flex-shrink: 0;
}

.log-row .tag {
  flex-shrink: 0;
  font-weight: bold;
  min-width: 40px;
  text-align: center;
}

.log-row .tag.send { color: #569cd6; }
.log-row .tag.receive { color: #ce9178; }
.log-row .tag.error { color: #f44747; }
.log-row .tag.connection { color: #c586c0; }

.log-row .content {
  color: #d4d4d4;
}

.empty-state {
  color: #555;
  text-align: center;
  margin-top: 40px;
  font-style: italic;
}
</style>
```



### 总结变化点



1. **布局策略**：从“内容撑开容器”变为“容器限制内容”。使用了 `height: 100vh` 和 `flex: 1` 结合 `overflow: auto`。
2. **侧边栏**：引入了 `config-scroll-area` 和 `panel-footer`，确保按钮永远在底部，而配置项在中间滚动。
3. **日志区**：去掉了 `el-card` 的硬性嵌套，直接使用 Flex 垂直布局，上半部分固定，下半部分自适应填充。
4. **视觉**：
   - 采用了更紧凑的间距。
   - 日志区使用了深色背景（类似 IDE 控制台），对比度更高，更符合开发者习惯。
   - 输入框去掉了默认的圆角和大边距，看起来更像一个整体的编辑器。

这套代码应用后，无论窗口怎么缩小，核心的“连接”按钮都在，且日志区域会自动适应高度，不会被切掉。